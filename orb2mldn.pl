#!/usr/bin/perl

################################################################################
#
#                          ORB2MLDN Version 1.3 
#                              Run Li, May 24, 2016
#
################################################################################
################################################################################
#This little script is written in PERL to convert orbitals.dat files generated by
#UNDMOL into Molden format, so that we can visualize the orbitals in MOLDEN.
#
#To use this script, copy it to bin/ directory under your home directory, change 
#its access by typing chmod +x orb2mldn.pl, and you can use it anywhere. (As long
#as you have this bin directory in you $PATH environmental variable.)
#
#Before you use it, you should already have 2 files: one being the orbital files 
#with the extension name of .dat, in the format of orbitals.dat file, the other 
#being a basis set file that is in the format of a gaussian basis set file. You 
#can easily download one from EMSL basis set exchange website. It is allowed to 
#keep the comment lines which start with exclamation marks, but please do not add
#any comments in the same line of coeffients.
#
#To use this script, you need to 1. type orb2mldn.pl in your working directory, 
#2.follow the instruction type in the name of the orbital data file and basis set 
#file name, should see your output file in the working directory with the 
#same name as your .dat file only with the extension of .mldn. You can then see the 
#orbitals with the Molden.
#
#When you use Molden to look at the orbitals, please note the occupation number 
#column does not show the true occupation numbers, but instead it show an indicator
#of the symmetry of the orbital. The first symmetry in your orbitals.dat file have 
#the "occupation number" of 0, the next symmetry will show 1, the third symmetry 
#will go back to 0, so on and so forth. For example, in a C2v calculation,
#orbital.dat file contains a1, a2, b1, b2, orbitals, so a1 and b1 orbitals will 
#display occupation numbers of 0, a2 and b2 will display 1. This way can help us
#quickly locate orbitals such as 1a2, 1b1, etc. However, by using this 
#notation, Molden cannot accurately identify the LOMO and HOMO orbitals, so the 
#button LUMO and HOMO do not work for us, and we need to determine them ourselves.
#
#Currently I tested this script on restricted/usrestricted spherical/cartesian 
#orbitals (up to G orbitals) without ECP. I only checked molecules of c2v symmetry.
#
#If your orbitals file is generated by a calculation that's not terminated correctly, 
#you may not have the geometry of the molecule in the file. All you need to do is
#to copy the geometry information from a different orbital file before running this 
#script.  
#
#******************************MODIFICATIONS*********************************
#
#Feb 27 2013: treat alpha beta spin correctly. Originally, it records functions with 
#the same symmetry at the same place without distinguishing the spin, (eg. 1a1 alpha
#and 1a1 beta are recorded together) Right now they are fixed. 
#
#July 7 2013: realising UNDMOL print orbitals only in spherical form even for cartesian
#calculations. However, if UNDMOL can print cartesian orbitals in the following order, 
#ORB2MLDN can deal with it by removing the relevent commment lines below.
#S, Px, Py,Pz, Dxx, Dxy, Dyy, Dxz, Dyz, Dzz, Fxxx, Fxxy, Fxyy, Fyyy, Fxxz, Fxyz, Fyyz
#Fxzz, Fyzz, Fzzz, Gxxxx, Gxxxy, Gxxyy, Gxyyy, Gyyyy, Gxxxz, Gxxyz, Gxyyz, Gyyyz, Gxxzz,
#Gxyzz, Gyyzz, Gxzzz, Gyzzz, Gzzzz
#
#May 24, 2016: fixed a bug in the code so that it can handle more than 100 orbitals of
#the same symmetry; added in the capability of dealing with G orbitals
#
##################################################################################  

use strict;
my @geom;
my %data;
my %energy;
my %symm;
my $name;
my ($IdAtom, $Atom, $FlagBasis,$OrbFile,$BasisFile,%Basis,$AtomBasis);
my @orbs;
my $IDMO;

#get geometry and orbital information

print "Please provide the name of the orbital file (eg. orbitals.dat):";
$OrbFile=<STDIN>;
chomp($OrbFile);
$OrbFile=~s/.dat//;

open FILEIN1,"<", "$OrbFile.dat" or die $!;
open FILEOUT,">", "$OrbFile.mldn" or die $!;

while(<FILEIN1>){
   if($_=~/(\s*\d+)\s*([a-z]+..)\s*(-?\d+\.\d+)$/){    #new orb
	my $flag_data=1;
	$IDMO++;
	$name=join " ", $1,$2,$IDMO;
	push @orbs,$name;
	$energy{$name}=$3;
	$symm{$name}=$2;
   }elsif($_=~/(\s*-?\d+\.\d+\s*)+/){     #data
	if($_=~/[a-df-zA-Z]/){          #geometry section
	   if($_=~/=/){}                   #energy line, ignore
	   else{                           #geometry coordinates
		$IdAtom++;
		$Atom=(split/ +/)[1];
		my $AtomNumTemp=(split/ +/)[2];
		my $AtomNum=(split/\./,$AtomNumTemp)[0];
		my $AtomXYZ=join " ", (split/ +/)[3],(split/ +/)[4],(split/ +/)[5];
		$geom[$IdAtom]=" $Atom $IdAtom $AtomNum $AtomXYZ ";
	   }
	}else{                             #orb data
	   chomp;
	   $data{$name}.=$_;              #record all basis coefficients in a single line
	}
   }
}

#get orbital information

print "Please provide the name of the basis set file:";
$BasisFile=<STDIN>;
chomp($BasisFile);
open FILEIN2,"<", "$BasisFile" or die $!;

while(<FILEIN2>){                #save all basis info to %Basis, keys are atomic simbols
   next if($_=~/^!/);                    
   if($_=~/\*+/){                        #end of an old atom, start for a new one
	$FlagBasis=0;
	next;
   }
   if($_=~/[A-Z][a-z]?\s+0/){           #molecule line,composed of atomic simbol and  0
	$AtomBasis=(split/ +/)[0];
	$FlagBasis=1;
	next;
   }
   if($_=~/\w/ && $FlagBasis==1){             #basis set data, top line not included
	$Basis{$AtomBasis} .=$_;
   }
}

#prepare stage:
#count how many AOs

$data{$orbs[0]}=~s/^\s+//;           #remove leading whitespace
my @AO=split/ +/, $data{$orbs[0]};
my $NumAO=scalar(@AO);
my $LastSymm=$symm{$orbs[0]};
my $FlagOccup=1;
my $NumMO=0;

#print to output file

print FILEOUT "[Molden Format]\n";

print FILEOUT "[Atoms] (AU)\n";
print FILEOUT @geom;

print FILEOUT "[GTO]\n";

my (@ns, @np, @nd, @nf, @ng);
for $IdAtom(1 .. @geom-1){
   $Atom=(split/ +/,$geom[$IdAtom])[1];
   print FILEOUT "$IdAtom  0\n";
   print FILEOUT "$Basis{$Atom}\n";
}

#######################################################################################
#Uncomment either of the following blocks
#Second block assumes the orbitals.dat file supports cartesian formats, user can turn it
#on by typing c for cartesian
#
###########################################################################################
#
#VERSION 1: ONLY HANDLE SPEHERICAL ORBITALS
print FILEOUT "[5D7F]\n";
print FILEOUT "[9G]\n";
#END OF VERSION 1
#
#########################################################################################
#
#VERSION 2: USER CAN CHOOSE IF SPEHERICAL OR CARTESIAN ORBITALS ARE USED
#   my @tempns=($Basis{$Atom}=~/s/ig);
#   my @tempnp=($Basis{$Atom}=~/p/ig);
#   my @tempnd=($Basis{$Atom}=~/d/ig);
#   my @tempnf=($Basis{$Atom}=~/f/ig);
#   my @tempng=($Basis{$Atom}=~/g/ig);
#   $ns[$IdAtom]=scalar(@tempns);
#   $np[$IdAtom]=scalar(@tempnp);
#   $nd[$IdAtom]=scalar(@tempnd);
#   $nf[$IdAtom]=scalar(@tempnf);
#   $ng[$IdAtom]=scalar(@tempng);
#}
#print "Does this calculation use spherical(5D7F) or cartesian(6D10F) basis? (s or c)";
#chomp( my $Flag5D=<STDIN>);
#print FILEOUT "[5D7F]\n[9G]\n" if ($Flag5D eq "s");
#END OF VERSION 2
#
###########################################################################################


print FILEOUT "[MO]\n";

foreach $name (@orbs){        #each MO
   $NumMO++;
   print FILEOUT "Sym=$symm{$name}\n";
   print FILEOUT "Ene=$energy{$name}\n";
   if($NumMO<=$NumAO){
	print FILEOUT "Spin=Alpha\n";
   }else{
	print FILEOUT "Spin=Beta\n";
   }
   if($symm{$name} ne $LastSymm){       #record the last occupation as this one
	$FlagOccup*=-1;         #flip occup, when FlagOccup==1,use 1 as occup, when Flag==-1, use 2
   }
   if($FlagOccup==1){
	print FILEOUT "Occup=0.0\n";
   }else{
	print FILEOUT "Occup=1.0\n";
   }
   $LastSymm=$symm{$name};
   $data{$name}=~s/^\s+//;           #remove leading whitespace
   my @coeffs=split/\s+/,$data{$name};
   my $IdCoeff=1;
############################################################
# turn on either of the two following blocks
# the first one does NOT support cartesian orbitals.dat format
#######################################################
#
#VERSION 1: ONLY HANDLE SPEHERICAL ORBITALS
#
   foreach my $coeff (@coeffs){
	print FILEOUT "$IdCoeff $coeff \n";
	$IdCoeff++;
   }
#END OF VERSION 1
#
#############################################################
#
#VERSION 2: USER CAN CHOOSE IF SPEHERICAL OR CARTESIAN ORBITALS ARE USED
#
#   if ($Flag5D eq "s"){
#   }else{                                   #cartesian basis
#	my $CountCoeff=1;
#	my $FullAtomCoeff=0;
#	$IdAtom=1;
#	while ($IdCoeff < @coeffs-1){
#		if ($IdCoeff <= $FullAtomCoeff+($ns[$IdAtom]+$np[$IdAtom]*3)){  # S or P orb
#		   print FILEOUT "$IdCoeff $coeffs[$IdCoeff-1] \n";
#		   $IdCoeff++;
#		}elsif ($IdCoeff == 1+($FullAtomCoeff+($ns[$IdAtom]+$np[$IdAtom]*3))){ # 1st D orb
#		   for my $tmpnd (1 .. $nd[$IdAtom]){                                
#			print FILEOUT "$IdCoeff $coeffs[$IdCoeff-1] \n";    #Dxx
#			print FILEOUT "$IdCoeff+1 $coeffs[$IdCoeff+1] \n";      #Dyy
#			print FILEOUT "$IdCoeff+2 $coeffs[$IdCoeff+4] \n";      #Dzz
#			print FILEOUT "$IdCoeff+3 $coeffs[$IdCoeff] \n";        #Dxy
#			print FILEOUT "$IdCoeff+4 $coeffs[$IdCoeff+2] \n";      #Dxz
#			print FILEOUT "$IdCoeff+5 $coeffs[$IdCoeff+3] \n";      #Dyz
#			$tmpnd++;
#			$IdCoeff+=6;
#		   }
#		}elsif ($IdCoeff == 1+($FullAtomCoeff+($ns[$IdAtom]+3*$np[$IdAtom]+6*$nd[$IdAtom]))){  #1st F orb
#		   for my $tmpnf (1 .. $nf[$IdAtom]){
#			print FILEOUT "$IdCoeff $coeffs[$IdCoeff-1] \n";      #Fxxx
#			print FILEOUT "$IdCoeff+1 $coeffs[$IdCoeff+2] \n";      #Fyyy
#			print FILEOUT "$IdCoeff+2 $coeffs[$IdCoeff+8] \n";      #Fzzz
#			print FILEOUT "$IdCoeff+3 $coeffs[$IdCoeff+1] \n";      #Fxyy
#			print FILEOUT "$IdCoeff+4 $coeffs[$IdCoeff  ] \n";      #Fxxy
#			print FILEOUT "$IdCoeff+5 $coeffs[$IdCoeff+3] \n";      #Fxxz
#			print FILEOUT "$IdCoeff+6 $coeffs[$IdCoeff+6] \n";      #Fxzz
#			print FILEOUT "$IdCoeff+7 $coeffs[$IdCoeff+5] \n";      #Fyzz
#			print FILEOUT "$IdCoeff+8 $coeffs[$IdCoeff+7] \n";      #Fyyz
#			print FILEOUT "$IdCoeff+9 $coeffs[$IdCoeff+4] \n";      #Fxyz
#			$tmpnf++;
#			$IdCoeff+=10;
#		   }
#		}elsif ($IdCoeff == 1+($FullAtomCoeff+($ns[$IdAtom]+3*$np[$IdAtom]+6*$nd[$IdAtom]+10*$nf[$IdAtom]))){  #1st G orb
#		   for my $tmpng (1 .. $ng[$IdAtom]){
#			print FILEOUT "$IdCoeff $coeffs[$IdCoeff-1] \n";         #Gxxxx
#			print FILEOUT "$IdCoeff+1 $coeffs[$IdCoeff+3] \n";       #Gyyyy
#			print FILEOUT "$IdCoeff+2 $coeffs[$IdCoeff+13] \n";      #Gzzzz
#			print FILEOUT "$IdCoeff+3 $coeffs[$IdCoeff] \n";         #Gxxxy
#			print FILEOUT "$IdCoeff+4 $coeffs[$IdCoeff+4] \n";       #Gxxxz
#			print FILEOUT "$IdCoeff+5 $coeffs[$IdCoeff+2] \n";       #Gyyyx
#			print FILEOUT "$IdCoeff+6 $coeffs[$IdCoeff+7] \n";       #Gyyyz
#			print FILEOUT "$IdCoeff+7 $coeffs[$IdCoeff+11] \n";      #Gzzzx
#			print FILEOUT "$IdCoeff+8 $coeffs[$IdCoeff+12] \n";      #Gzzzy
#			print FILEOUT "$IdCoeff+9 $coeffs[$IdCoeff+1] \n";       #Gxxyy
#			print FILEOUT "$IdCoeff+10 $coeffs[$IdCoeff+8] \n";      #Gxxzz
#			print FILEOUT "$IdCoeff+11 $coeffs[$IdCoeff+10] \n";     #Gyyzz
#			print FILEOUT "$IdCoeff+12 $coeffs[$IdCoeff+5] \n";      #Gxxyz
#			print FILEOUT "$IdCoeff+13 $coeffs[$IdCoeff+6] \n";      #Gyyxz
#			print FILEOUT "$IdCoeff+14 $coeffs[$IdCoeff+9] \n";      #Gzzxy
#			$tmpng++;
#			$IdCoeff+=15;
#		   }
#		}
#		if ($IdCoeff == 1+$FullAtomCoeff+($ns[$IdAtom]+3*$np[$IdAtom]+6*$nd[$IdAtom]+10*$nf[$IdAtom]+15*$ng[$IdAtom])){
#			$IdAtom++;
#			$FullAtomCoeff=$IdCoeff-1;                                      #total Number of Coeffs for full atoms recorded
#		}
#	   }
#   } 
#
#END OF VERSION 2
#
######################################################################################################################################


}


print "Check $OrbFile.mldn for output!\n";
close FILEIN1;
close FILEIN2;
close FILEOUT;




